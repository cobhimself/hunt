<?php

namespace Hunt\Component\Gatherer;

use Hunt\Bundle\Models\Result;
use Hunt\Component\MatchContext\ContextCollectorFactory;
use RuntimeException;

abstract class AbstractGatherer implements GathererInterface
{
    /**
     * The term we are searching for.
     *
     * @var string
     */
    protected $term;

    protected $numContextLines = 0;

    /**
     * A list of exclude terms.
     *
     * @var array
     */
    protected $exclude;

    /**
     * Whether or not to trim spaces from the beginning of matching lines.
     *
     * @var bool
     */
    protected $trimMatchingLines = false;

    /**
     * The line as we are working on it.
     *
     * @since 1.4.0
     *
     * @var string
     */
    protected $workingLine = '';

    /**
     * @codeCoverageIgnore
     */
    public function __construct(string $term, array $exclude = null)
    {
        if (empty($term)) {
            throw new \InvalidArgumentException('You must specify a term!');
        }

        $this->term = $term;
        $this->exclude = (is_array($exclude)) ? $exclude : [];
    }

    /**
     * Whether or not the given line matches.
     *
     * @param string $line
     * @return bool
     */
    abstract public function lineMatches(string $line): bool;

    /**
     * Gather a set of matching lines from the Result's file.
     *
     * @throws RuntimeException
     *
     * @return bool true if we still have matches, false otherwise
     */
    public function gather(Result $result): bool
    {
        $matchingLines = [];
        $contextCollector = ContextCollectorFactory::get($this->getNumContextLines());

        foreach ($result->getFileIterator() as $num => $line) {

            //Our code starts at line 1, unlike our arrays.
            $codeLineNum = $num + 1;

            $testLine = $line;
            if (null !== $this->exclude && is_array($this->exclude)) {
                foreach ($this->exclude as $excludeTerm) {
                    $testLine = str_replace($excludeTerm, '', $testLine);
                }
            }
            $lineMatches = $this->lineMatches($testLine);

            if ($lineMatches) {
                $matchingLines[$codeLineNum] = $line;
            }
            $contextCollector->addLine($codeLineNum, $line, $lineMatches);
        }
        $contextCollector->finalize();

        $result->setContextCollection($contextCollector->getContextCollection());
        $result->setMatchingLines($matchingLines);

        return count($matchingLines) > 0;
    }

    /**
     * Returns the given line with the term highlighted.
     *
     * Excluded terms are not highlighted.
     */
    public function getHighlightedLine(string $line, string $highlightStart = '', string $highlightEnd = ''): string
    {
        $this->workingLine = $line;
        $translateArray = $this->removeExcludedTerms();

        $this->workingLine = $this->highlightLine($this->workingLine, $highlightStart, $highlightEnd);

        return $this->addExcludedTermsBack($translateArray);
    }

    /**
     * We replace our excluded words with placeholders so our highlight matches ignore them.
     *
     * @since 1.4.0
     *
     * @return array an array of translations we used with our placeholders
     */
    protected function removeExcludedTerms(): array
    {
        //Exit early if we can.
        if (0 === count($this->exclude)) {
            return [];
        }

        //We could use regex but it's possible the complexity would cause the search to take a long time. Therefore,
        //we are going to replace our exclude terms with placeholders, highlight our original term, and then put our
        //exclude terms back.
        static $placeholder = "\u{731f}\u{5e2b}";
        $counter = 0;

        //We need to build a translation between our exclude terms and the placeholders
        $translate = [];
        foreach ($this->exclude as $exclude) {
            ++$counter;
            $translate[$exclude] = str_repeat($placeholder, $counter);
        }
        $this->workingLine = strtr($this->workingLine, $translate);

        return $translate;
    }

    /**
     * Add our excluded terms back based on the given translation array.
     *
     * @since 1.4.0
     *
     * @param array $translate we flip this translation array since we assume it was generated by removeExcludedTerms
     */
    protected function addExcludedTermsBack(array $translate): string
    {
        //Exit early if we can
        if (0 === count($this->exclude)) {
            return $this->workingLine;
        }

        //Reverse our placeholder translation
        $translate = array_flip($translate);

        return strtr($this->workingLine, $translate);
    }

    /**
     * Perform the highlighting of the given line.
     */
    public function highlightLine(
        string $line,
        string $highlightStart = '',
        string $highlightEnd = ''
    ): string
    {
        throw new RuntimeException('highlightLine method must be overridden!');

    }

    /**
     * @param int $numContextLines The number of lines, before and after, we want to provide alongside our matching lines.
     *
     * @return GathererInterface
     */
    public function setNumContextLines(int $numContextLines): GathererInterface
    {
        $this->numContextLines = $numContextLines;

        return $this;
    }

    /**
     * Get the number of lines we want to provide before and after our matching line.
     */
    public function getNumContextLines(): int
    {
        return $this->numContextLines;
    }
}
